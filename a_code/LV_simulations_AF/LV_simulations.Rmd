---
title: "LV simulations - effect of species' co-responses to the environment on community dynamics"
---


In the mathematical formulation, we demonstrated that, in a LV system, the mean and variance in abundance change of a species $i$ is affected by how species' covary in their responses to the environment, i.e. growth rate $r_i$, and the way these propagate through the network which depends on the the interaction coefficients:

FORMULA (10)

$$
\text{var}\left( \Delta X_i \right) \approx \sum_k \sum_l b_{ik} b_{il} \text{cov}\left( \Delta r_k, \Delta r_l \right) \tag{11}
$$


A general prediction that can be drawn from FORMULA (11) is that a community with weaker covariance among species (closer to 0) should be more predictable (i.e. lead to lower species' variance in abundance change) compared to communities with stronger covariances.


We now test this predictions measuring changes in abundance in LV foodweb systems with varying underlying covariance structures.






```{r}
library(ggplot2)
library(tidyr)
library(dplyr)
library(Matrix)
library(deSolve)
library(clusterGeneration)
library(mvtnorm)
library(gridExtra)


############################################## FUNCTIONS

# Function to simulate dynamics
fw.model <- function(t, B, params) {
  with(as.list(c(B, params)), {
    B[B < 10^-8] <- 0 
    B[B < 0] <- 0 
    dBdt <- (params$r + params$A %*% B) * B
    dBdt[B > 100] <- 100  # Apply carrying capacity constraint  ########## !
    list(dBdt)
  })
}

eventfun <- function(t, B, parms) {
  with(as.list(B), {
    B[B < 1e-6] <- 0
    return(B)
  })
}

simulate_dynamics_c <- function(params, model, init_biomass = runif(params$S, min = 1, max = 10)) {
  init_biomass <- as.numeric(init_biomass)
  times <- seq(from = 1, to = params$maxt)
  out <- deSolve::ode(
    y = init_biomass,
    times = times,
    func = fw.model,
    parms = params,
    events = list(func = eventfun, time = times)
  ) %>% as.data.frame()
  return(out)
}

# Function to simulate a fixed quantitative interaction network
sim_quantitative_network <- function(S, C, aij_params) {
  A <- matrix(0, S, S)
  n_pairs <- S * (S - 1) / 2
  B <- runif(n_pairs) <= C
  
  aij <- -abs(rnorm(n_pairs, aij_params[1], aij_params[2]))
  A[upper.tri(A)] <- B * aij
  A <- t(A)
  aij <- abs(rnorm(n_pairs, aij_params[1], aij_params[2]))
  A[upper.tri(A)] <- B * aij
  diag(A) <- -runif(S, min = 0, max = 1)
  
  while(max(Re(eigen(A)$values)) > 0) {
    diag(A) <- -runif(S, min = 0, max = 1)
  }
  return(A)
}

# Function to simulate dynamics with perturbations
simulate_dynamics_perturbed <- function(params, covMat, S, maxt, perturb_scale = 1) {
  init_biomass <- runif(S, min = 1, max = 10)
  r_pre <- -params$A %*% init_biomass
  
  dyn_params <- list(A = params$A, r = r_pre, S = S, maxt = maxt) 
  pre_perturb <- simulate_dynamics_c(dyn_params, fw.model)
  equilibrium_pre <- as.numeric(pre_perturb[nrow(pre_perturb), -1])
  
  r_perturbation <- MASS::mvrnorm(n = 1, mu = r_pre, Sigma = covMat * perturb_scale)
  dyn_params$r <- matrix(r_perturbation, nrow = S, ncol = 1)
  
  post_perturb <- simulate_dynamics_c(dyn_params, fw.model, init_biomass = equilibrium_pre)
  equilibrium_post <- as.numeric(post_perturb[nrow(post_perturb), -1])
  
  delta_X <- equilibrium_post - equilibrium_pre
  return(list(delta_r = dyn_params$r - r_pre, delta_X = delta_X))
}


############################################## SIMULATION

# Set simulation parameters
S <- 8  # Number of species
C <- 0.2  # Connectance of the network
aij_params <- c(0, 0.5)
sd_X <- 1  # Variance scale factor
num_scenarios <- 10
num_simulations <- 10
maxt <- 1000  # Duration of the simulation

# Fixed interaction matrix A
A <- sim_quantitative_network(S, C, aij_params)

# Initialize data frames to store results
results <- data.frame()
correlation_distributions <- data.frame()
covariance_distributions <- data.frame()

# Loop over two alpha_d values: 0.001 and 40
for (alpha_d in c(0.001, 40)) {
  print(paste("alpha_d", alpha_d))
  
  for (scenario in 1:num_scenarios) {
    print(paste("scenario", scenario, "of", num_scenarios))
    
    # Generate correlation matrix and derive covariance matrix
    cor_matrix <- clusterGeneration::rcorrmatrix(d = S, alphad = alpha_d)
    covMat <- diag(sd_X, S) %*% cor_matrix %*% diag(sd_X, S)
    
    # Store correlation and covariance values for plotting
    cor_vals <- cor_matrix[upper.tri(cor_matrix, diag = FALSE)]
    cov_vals <- covMat[upper.tri(covMat, diag = FALSE)]
    
    correlation_distributions <- rbind(correlation_distributions,
                                       data.frame(Alpha_d = alpha_d, Scenario = scenario, Correlation = cor_vals))
    covariance_distributions <- rbind(covariance_distributions,
                                      data.frame(Alpha_d = alpha_d, Scenario = scenario, Covariance = cov_vals))
    
    for (sim in 1:num_simulations) {
      print(paste("sim", sim, "of", num_simulations))
      
      # Run the simulation with perturbations
      sim_result <- simulate_dynamics_perturbed(list(A = A), covMat, S, maxt)
      
      # Store the results
      for (species in 1:S) {
        results <- rbind(results, data.frame(
          Alpha_d = alpha_d,
          Scenario = scenario,
          Simulation = sim,
          Species = paste0("sp", species),
          Delta_X = sim_result$delta_X[species]
        ))
      }
    }
  }
}

# Compute standard deviation of Delta_X for each species and alpha_d value
expected_delta_X <- results %>%
  group_by(Alpha_d, Species) %>%
  summarize(sd_Delta_X = sd(Delta_X))

# Plot comparing sd_Delta_X between alpha_d scenarios across all species
ggplot(expected_delta_X, aes(x = as.factor(Alpha_d), y = sd_Delta_X, fill = as.factor(Alpha_d))) +
  geom_boxplot() +
  labs(x = "Alpha_d", y = "SD Delta_X Across All Species", fill = "Alpha_d") +
  scale_fill_manual(values = c("#6A0DAD", "#EAD7F5")) +
  theme_minimal() +
  ggtitle("Comparison of SD Delta_X Across Alpha_d Scenarios for All Species") +
  theme(legend.position = "none")

# Plot distribution of correlation values across scenarios
ggplot(correlation_distributions, aes(x = Correlation, fill = as.factor(Alpha_d))) +
  geom_density(alpha = 0.7) +
  labs(x = "Correlation Value", y = "Density", fill = "Alpha_d") +
  scale_fill_manual(values = c("#6A0DAD", "#EAD7F5")) +
  xlim(-1, 1) +
  ggtitle("Distribution of Correlation Values Across All Scenarios") +
  theme_minimal()

# Plot distribution of covariance values across scenarios
ggplot(covariance_distributions, aes(x = Covariance, fill = as.factor(Alpha_d))) +
  geom_density(alpha = 0.7) +
  labs(x = "Covariance Value", y = "Density", fill = "Alpha_d") +
  scale_fill_manual(values = c("#6A0DAD", "#EAD7F5")) +
  xlim(-1, 1) +
  ggtitle("Distribution of Covariance Values Across All Scenarios") +
  theme_minimal()

```


- No differences between scenarios with different strengths in species' covariances.


# simulation with formula

```{r}


# Define function to calculate variance of ΔX over multiple simulations
simulate_variance_multiple_runs <- function(S, alpha_d, interaction_sd, num_simulations) {
  results <- replicate(num_simulations, {
    # Generate covariance matrix for Δr
    cor_matrix <- clusterGeneration::rcorrmatrix(d = S, alphad = alpha_d)
    cov_matrix <- diag(sd_X, S) %*% cor_matrix %*% diag(sd_X, S)
    
    # Generate interaction coefficients with increased variance
    interaction_matrix <- matrix(rnorm(S^2, mean = 0, sd = interaction_sd), nrow = S)
    
    # Calculate variance of ΔX using formula 11
    var_delta_X <- sapply(1:S, function(i) {
      sum(sapply(1:S, function(k) {
        sapply(1:S, function(l) {
          interaction_matrix[i, k] * interaction_matrix[i, l] * cov_matrix[k, l]
        })
      }))
    })
    
    return(var_delta_X)
  })
  
  # Convert to data frame
  var_delta_X_df <- as.data.frame(t(results))
  var_delta_X_df <- var_delta_X_df %>%
    pivot_longer(cols = everything(), names_to = "Species", values_to = "Variance_Delta_X") %>%
    mutate(Alpha_d = alpha_d)
  
  return(var_delta_X_df)
}

# Parameters
S <- 8
sd_X <- 1
alpha_d_values <- c(0.1, 40)
interaction_sd <- 2  # Increased standard deviation for interaction coefficients
num_simulations <- 100

# Run simulations for both alpha_d values
results_list <- lapply(alpha_d_values, function(alpha_d) {
  simulate_variance_multiple_runs(S, alpha_d, interaction_sd, num_simulations)
})

# Combine results and plot
results_df <- bind_rows(results_list)

# Boxplot to compare the variance of ΔX
ggplot(results_df, aes(x = as.factor(Alpha_d), y = Variance_Delta_X, fill = as.factor(Alpha_d))) +
  geom_boxplot() +
  labs(x = "Alpha_d", y = "Variance of ΔX", fill = "Alpha_d") +
  scale_fill_manual(values = c("#6A0DAD", "#EAD7F5")) +
  theme_minimal() +
  ggtitle("Comparison of Variance of ΔX Across Alpha_d Scenarios with Increased Interaction Coefficient Variance") +
  theme(legend.position = "none")


```


## checks


The "realized" covariance of species' abundance are driven by both species' covariance in responses to the environment and their interaction coefficients. 

$$
\text{cov}\left( \Delta X_i, \Delta X_j \right) \approx \sum_k \sum_l b_{ik} b_{il} \text{cov}\left( \Delta r_k, \Delta r_l \right) \tag{12}
$$



1. Does the C matrix have the expected effect on delta_r values?


We test this by leaving out the effect of interactions and making the C matrix to be the only driver of abundance changes. To do this, we only consider the identify matrix of the interaction matrix A, so that species are only influenced by themselves.




```{r}

# Function to simulate and visualize biomass dynamics
inspect_biomass_dynamics <- function(A, covMat, S, maxt, perturb_scale = 1) {
  
  # Initial biomass values as numeric vector
  init_biomass <- as.numeric(runif(S, min = 1, max = 10))
  
  # Pre-perturbation growth rates
  r_pre <- as.numeric(-A %*% init_biomass)
  
  # Define the Lotka-Volterra model dynamics function
  fw_model <- function(t, B, params) {
    with(as.list(c(B, params)), {
      B[B < 10^-8] <- 0  # Ensure non-negative biomass
      dBdt <- (params$r + params$A %*% B) * B
      return(list(dBdt))
    })
  }
  
  # Simulate pre-perturbation dynamics
  dyn_params <- list(A = A, r = r_pre, S = S, maxt = maxt)
  pre_perturb <- deSolve::ode(
    y = init_biomass,
    times = seq(0, maxt, by = 1),
    func = fw_model,
    parms = dyn_params
  ) %>% as.data.frame()
  
  # Perturb the growth rates using the covariance matrix
  r_perturbation <- MASS::mvrnorm(n = 1, mu = r_pre, Sigma = covMat * perturb_scale)
  print(paste("r_perturbation:",r_perturbation))
  
  dyn_params$r <- as.numeric(r_perturbation)
  
  # Simulate post-perturbation dynamics
  post_perturb <- deSolve::ode(
    y = as.numeric(pre_perturb[nrow(pre_perturb), -1]),
    times = seq(0, maxt, by = 1),
    func = fw_model,
    parms = dyn_params
  ) %>% as.data.frame()
  
  # Prepare data for plotting
  pre_perturb_long <- pre_perturb %>%
    pivot_longer(cols = -time, names_to = "Species", values_to = "Biomass") %>%
    mutate(Phase = "Pre-Perturbation")
  
  post_perturb_long <- post_perturb %>%
    pivot_longer(cols = -time, names_to = "Species", values_to = "Biomass") %>%
    mutate(Phase = "Post-Perturbation")
  
  biomass_dynamics <- bind_rows(pre_perturb_long, post_perturb_long)
  
  # Plot the biomass dynamics
  ggplot(biomass_dynamics, aes(x = time, y = Biomass, color = Species)) +
    geom_line() +
    facet_wrap(~Phase, scales = "free_y") +
    labs(title = "Biomass Dynamics Over Time", x = "Time", y = "Biomass") +
    theme_minimal() +
    scale_color_viridis_d()
}

# Example parameters
S <- 8  # Number of species
maxt <- 1000  # Maximum time for simulation
perturb_scale <- 1  # Perturbation scale factor

# Example matrices (identity for A, and random for covMat)
#A_identity <- diag(1, S)
A <- sim_quantitative_network(S, C, aij_params)
covMat <- clusterGeneration::rcorrmatrix(d = S, alphad = 40)

# Run the inspection function
inspect_biomass_dynamics(A = A, 
                         covMat = covMat, 
                         S = S, 
                         maxt = maxt, 
                         perturb_scale = perturb_scale)


```






- simulating very weak interactions
- scaling covariance by sd_X = 0.01 to get normal correlation values in sd_X


```{r}


# Function to create a scaled down interaction matrix
sim_weak_interaction_network <- function(S, C, aij_params, scale_factor = 0.01) {
  A <- matrix(0, S, S)
  n_pairs <- S * (S - 1) / 2
  B <- runif(n_pairs) <= C
  
  aij <- -abs(rnorm(n_pairs, aij_params[1], aij_params[2]))
  A[upper.tri(A)] <- B * aij
  A <- t(A)
  aij <- abs(rnorm(n_pairs, aij_params[1], aij_params[2]))
  A[upper.tri(A)] <- B * aij
  
  diag(A) <- -runif(S, min = 0, max = 1)
  while (max(Re(eigen(A)$values)) > 0) {
    diag(A) <- -runif(S, min = 0, max = 1)
  }
  
  # Scale down the matrix
  A_scaled <- A * scale_factor
  return(A_scaled)
}

# Function for weak interspecific effects dynamics
simulate_dynamics_weak <- function(params, covMat, S, maxt, perturb_scale = 1) {
  init_biomass <- runif(S, min = 1, max = 10)
  r_pre <- -params$A %*% init_biomass
  
  dyn_params <- list(A = params$A, r = r_pre, S = S, maxt = maxt) 
  pre_perturb <- simulate_dynamics_c(dyn_params, fw.model)
  equilibrium_pre <- as.numeric(pre_perturb[nrow(pre_perturb), -1])
  
  r_perturbation <- MASS::mvrnorm(n = 1, mu = r_pre, Sigma = covMat * perturb_scale)
  dyn_params$r <- matrix(r_perturbation, nrow = S, ncol = 1)
  
  post_perturb <- simulate_dynamics_c(dyn_params, fw.model, init_biomass = equilibrium_pre)
  equilibrium_post <- as.numeric(post_perturb[nrow(post_perturb), -1])
  
  delta_X <- equilibrium_post - equilibrium_pre
  return(list(delta_r = dyn_params$r - r_pre, delta_X = delta_X))
}

# Simulation parameters
S <- 8  # Number of species
C <- 0.2  # Connectance
aij_params <- c(0, 0.5)
sd_X <- 0.01  # Variance scale factor
alpha_d <- 10  # Correlation structure parameter
num_scenarios <- 10
num_simulations <- 10
maxt <- 1000  # Time

# Generate very weak interaction matrix
A_weak <- sim_weak_interaction_network(S, C, aij_params)

# Generate correlation and covariance matrices for delta_r
cor_matrix <- clusterGeneration::rcorrmatrix(d = S, alphad = alpha_d)
covMat <- diag(sd_X, S) %*% cor_matrix %*% diag(sd_X, S)

# Run the simulation
results <- data.frame()
for (i in 1:num_scenarios) {
  for (j in 1:num_simulations) {
    sim_result <- simulate_dynamics_weak(list(A = A_weak), covMat, S, maxt)
    delta_r <- sim_result$delta_r
    delta_X <- sim_result$delta_X
    
    results <- rbind(results, data.frame(
      Scenario = i,
      Simulation = j,
      Species = 1:S,
      Delta_X = delta_X,
      Delta_r = delta_r
    ))
  }
}

# Reshape the data into wide format, keeping only Delta_X and Delta_r values
delta_X_matrix <- results %>%
  dplyr::select(Species, Scenario, Simulation, Delta_X) %>%
  pivot_wider(names_from = Species, values_from = Delta_X) %>%
  as.matrix()

delta_r_matrix <- results %>%
  dplyr::select(Species, Scenario, Simulation, Delta_r) %>%
  pivot_wider(names_from = Species, values_from = Delta_r) %>%
  as.matrix()

# Ensure no additional filtering is applied
# Convert both matrices to numeric matrices if necessary
delta_X_matrix <- matrix(as.numeric(delta_X_matrix), nrow = nrow(delta_X_matrix))
delta_r_matrix <- matrix(as.numeric(delta_r_matrix), nrow = nrow(delta_r_matrix))

# Compute the covariance matrices
cov_delta_X <- cov(delta_X_matrix, use = "complete.obs")
cov_delta_r <- cov(delta_r_matrix, use = "complete.obs")

# Print to verify the matrices
print(cov_delta_X)
print(cov_delta_r)


# Convert covariance matrices to correlation matrices for plotting
cor_delta_X <- cov2cor(cov_delta_X)
cor_delta_r <- cov2cor(cov_delta_r)

# Melt the correlation matrices for plotting
corr_melt_X <- melt(cov_delta_X)
colnames(corr_melt_X) <- c("Var1", "Var2", "Correlation")

corr_melt_r <- melt(cov_delta_r)
colnames(corr_melt_r) <- c("Var1", "Var2", "Correlation")

# Plot correlation matrices for Delta_X and Delta_r
p1 <- ggplot(corr_melt_X, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdBu") +
  labs(title = "Correlation Matrix for Delta_X") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank())

p2 <- ggplot(corr_melt_r, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdBu") +
  labs(title = "Correlation Matrix for Delta_r") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title = element_blank())

# Display both plots side by side
gridExtra::grid.arrange(p1, p2, ncol = 2)




```

```{r}
# Function to simulate dynamics without interspecific effects
simulate_identity_dynamics <- function(params, covMat, S, maxt, perturb_scale = 1) {
  init_biomass <- runif(S, min = 1, max = 10)
  r_pre <- -params$A %*% init_biomass
  
  dyn_params <- list(A = params$A, r = r_pre, S = S, maxt = maxt) 
  pre_perturb <- simulate_dynamics_c(dyn_params, fw.model)
  equilibrium_pre <- as.numeric(pre_perturb[nrow(pre_perturb), -1])
  
  # Perturb r using the covariance matrix
  r_perturbation <- MASS::mvrnorm(n = 1, mu = r_pre, Sigma = covMat * perturb_scale)
  dyn_params$r <- matrix(r_perturbation, nrow = S, ncol = 1)
  
  # Simulate post-perturbation dynamics
  post_perturb <- simulate_dynamics_c(dyn_params, fw.model, init_biomass = equilibrium_pre)
  equilibrium_post <- as.numeric(post_perturb[nrow(post_perturb), -1])
  
  delta_X <- equilibrium_post - equilibrium_pre
  return(list(delta_r = dyn_params$r - r_pre, delta_X = delta_X))
}

# Set up the simulation
S <- 8
C <- 0.2
sd_X <- 1
alpha_d <- 40  # Adjust alpha_d as needed

# Create the identity matrix for A (no interspecific interactions)
A_identity <- diag(1, S)

# Generate the correlation and covariance matrices for delta_r
cor_matrix <- clusterGeneration::rcorrmatrix(d = S, alphad = alpha_d)
covMat <- diag(sd_X, S) %*% cor_matrix %*% diag(sd_X, S)

# Run the simulation
results <- data.frame()
for (i in 1:10) {  # 10 simulations for example
  sim_result <- simulate_identity_dynamics(list(A = A_identity), covMat, S, maxt = 1000)
  delta_r <- sim_result$delta_r
  delta_X <- sim_result$delta_X
  
  results <- rbind(results, data.frame(
    Simulation = i,
    Species = 1:S,
    Delta_X = delta_X,
    Delta_r = delta_r
  ))
}

# Compute covariances in Delta_X and Delta_r
cov_delta_X <- cov(dplyr::select(results, starts_with("Delta_X")))
cov_delta_r <- cov(dplyr::select(results, starts_with("Delta_r")))

# Plot the correlation matrices
corr_melt_X <- melt(cov2cor(cov_delta_X))
colnames(corr_melt_X) <- c("Var1", "Var2", "Correlation")

corr_melt_r <- melt(cov2cor(cov_delta_r))
colnames(corr_melt_r) <- c("Var1", "Var2", "Correlation")

p1 <- ggplot(corr_melt_X, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdBu", limits = c(-1, 1)) +
  labs(title = "Correlation Matrix for Delta_X") +
  theme_minimal()

p2 <- ggplot(corr_melt_r, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdBu", limits = c(-1, 1)) +
  labs(title = "Correlation Matrix for Delta_r") +
  theme_minimal()

# Display both plots
gridExtra::grid.arrange(p1, p2, ncol = 2)

```

```{r}
library(ggplot2)
library(tidyr)
library(dplyr)
library(Matrix)
library(deSolve)
library(clusterGeneration)
library(mvtnorm)
library(gridExtra)

# Function to simulate dynamics with identity matrix
simulate_identity_dynamics <- function(params, covMat, S, maxt, perturb_scale = 1) {
  init_biomass <- runif(S, min = 1, max = 10)
  r_pre <- -params$A %*% init_biomass
  
  dyn_params <- list(A = params$A, r = r_pre, S = S, maxt = maxt) 
  pre_perturb <- simulate_dynamics_c(dyn_params, fw.model)
  equilibrium_pre <- as.numeric(pre_perturb[nrow(pre_perturb), -1])
  
  # Perturb r using the covariance matrix
  r_perturbation <- MASS::mvrnorm(n = 1, mu = r_pre, Sigma = covMat * perturb_scale)
  dyn_params$r <- matrix(r_perturbation, nrow = S, ncol = 1)
  
  # Simulate post-perturbation dynamics
  post_perturb <- simulate_dynamics_c(dyn_params, fw.model, init_biomass = equilibrium_pre)
  equilibrium_post <- as.numeric(post_perturb[nrow(post_perturb), -1])
  
  # Return both the dynamics and equilibrium
  return(list(pre_perturb = pre_perturb, post_perturb = post_perturb, delta_X = equilibrium_post - equilibrium_pre))
}

# Set up the simulation
S <- 8
C <- 0.2
sd_X <- 1
alpha_d <- 40
maxt <- 1000

# Identity matrix for A
A_identity <- diag(1, S)

# Generate correlation and covariance matrices
cor_matrix <- clusterGeneration::rcorrmatrix(d = S, alphad = alpha_d)
covMat <- diag(sd_X, S) %*% cor_matrix %*% diag(sd_X, S)

# Run the simulation
sim_result <- simulate_identity_dynamics(list(A = A_identity), covMat, S, maxt)

# Prepare data for plotting biomass dynamics
pre_perturb_long <- sim_result$pre_perturb %>%
  pivot_longer(cols = -time, names_to = "Species", values_to = "Biomass") %>%
  mutate(Phase = "Pre-Perturbation")

post_perturb_long <- sim_result$post_perturb %>%
  pivot_longer(cols = -time, names_to = "Species", values_to = "Biomass") %>%
  mutate(Phase = "Post-Perturbation")

biomass_dynamics <- bind_rows(pre_perturb_long, post_perturb_long)

# Plot the biomass dynamics for each species
ggplot(biomass_dynamics, aes(x = time, y = Biomass, color = Species)) +
  geom_line() +
  facet_wrap(~Phase, scales = "free_y") +
  labs(title = "Biomass Dynamics Over Time", x = "Time", y = "Biomass") +
  theme_minimal() +
  scale_color_viridis_d()

# Plot the correlation matrices as before
corr_melt_X <- melt(cov2cor(cov(sim_result$delta_X)))
colnames(corr_melt_X) <- c("Var1", "Var2", "Correlation")

corr_melt_r <- melt(cov2cor(cov(sim_result$delta_r)))
colnames(corr_melt_r) <- c("Var1", "Var2", "Correlation")

p1 <- ggplot(corr_melt_X, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdBu", limits = c(-1, 1)) +
  labs(title = "Correlation Matrix for Delta_X") +
  theme_minimal()

p2 <- ggplot(corr_melt_r, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile() +
  scale_fill_distiller(palette = "RdBu", limits = c(-1, 1)) +
  labs(title = "Correlation Matrix for Delta_r") +
  theme_minimal()

gridExtra::grid.arrange(p1, p2, ncol = 2)

```


