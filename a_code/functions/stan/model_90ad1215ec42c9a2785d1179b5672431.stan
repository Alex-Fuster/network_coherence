// Stan model code generated by package mvgam
functions {
vector rep_each(vector x, int K) {
int N = rows(x);
vector[N * K] y;
int pos = 1;
for (n in 1:N) {
for (k in 1:K) {
y[pos] = x[n];
pos += 1;
}
}
return y;
}

real lambda_gp(real L, int m) {
real lam;
lam = ((m*pi())/(2*L))^2;
return lam;
}

vector drift_SE(real L, int m, vector x) {
vector[rows(x)] fi;
fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
return fi;
}

real spd_SE(real alpha, real rho, real w) {
real S;
S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
return S;
}
}

data {
int<lower=0> total_obs; // total number of observations
int<lower=0> n; // number of timepoints per series
int<lower=0> n_lv; // number of dynamic factors
int<lower=0> n_sp; // number of smoothing parameters
int<lower=0> n_series; // number of series
int<lower=0> num_basis; // total number of basis coefficients
vector[num_basis] zero; // prior locations for basis coefficients
real p_taus[1]; // prior precisions for parametric coefficients
real p_coefs[1]; // prior locations for parametric coefficients
matrix[total_obs, num_basis] X; // mgcv GAM design matrix
int<lower=0> ytimes[n, n_series]; // time-ordered matrix (which col in X belongs to each [time, series] observation?)
matrix[8,16] S1; // mgcv smooth penalty matrix S1
int<lower=0> n_nonmissing; // number of nonmissing observations
vector[n_nonmissing] flat_ys; // flattened nonmissing observations
matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations
int<lower=0> obs_ind[n_nonmissing]; // indices of nonmissing observations
}
transformed data {
vector<lower=1>[n] times;
vector[n] times_cent;
real mean_times;
real<lower=0> boundary;
int<lower=1> num_gp_basis;
num_gp_basis = min(20, n);
matrix[n, num_gp_basis] gp_drift;

for (t in 1:n){
times[t] = t;
}

mean_times = mean(times);
times_cent = times - mean_times;
boundary = (5.0/4) * (max(times_cent) - min(times_cent));
for (m in 1:num_gp_basis){
gp_drift[,m] = drift_SE(boundary, m, times_cent);
}

// Number of non-zero lower triangular factor loadings
// Ensures identifiability of the model - no rotation of factors
int<lower=1> M;
M = n_lv * (n_series - n_lv) + n_lv * (n_lv - 1) / 2 + n_lv;
}

parameters {
// raw basis coefficients
vector[num_basis] b_raw;
// gaussian observation error
vector<lower=0>[n_series] sigma_obs;

// random effect variances
vector<lower=0>[1] sigma_raw;

// random effect means
vector[1] mu_raw;

// dynamic factor lower triangle loading coefficients
vector[M] L;

// gp parameters
vector<lower=0>[n_lv] rho_gp;

// gp coefficient weights
matrix[num_gp_basis, n_lv] b_gp;
// smoothing parameters

vector<lower=0>[n_sp] lambda;
}

transformed parameters {
// gp spectral densities
matrix[n, n_lv] LV_raw;
matrix[num_gp_basis, n_lv] diag_SPD;
matrix[num_gp_basis, n_lv] SPD_beta;

// trends and dynamic factor loading matrix
matrix[n, n_series] trend;
matrix[n_series, n_lv] lv_coefs_raw;

// basis coefficients
vector[num_basis] b;

b[1:9] = b_raw[1:9];
b[10:38] = mu_raw[1] + b_raw[10:38] * sigma_raw[1];

// constraints allow identifiability of loadings
for (i in 1:(n_lv - 1)) {
for (j in (i + 1):(n_lv)){
lv_coefs_raw[i, j] = 0;
}
}
{
int index;
index = 0;
for (j in 1:n_lv) {
for (i in j:n_series) {
index = index + 1;
lv_coefs_raw[i, j] = L[index];
}
}
}


// gp LV estimates
for (m in 1:num_gp_basis){
for (s in 1:n_lv){
diag_SPD[m, s] = sqrt(spd_SE(0.25, rho_gp[s], sqrt(lambda_gp(boundary, m))));
}
}
SPD_beta = diag_SPD .* b_gp;
LV_raw = gp_drift * SPD_beta;
// derived latent trends
for (i in 1:n){;
for (s in 1:n_series){
trend[i, s] = dot_product(lv_coefs_raw[s,], LV_raw[i,1:n_lv]);
}
}

}

model {
// prior for random effect population variances
sigma_raw ~ exponential(0.5);

// prior for random effect population means
mu_raw ~ std_normal();

// parametric effect priors (regularised for identifiability)
for (i in 1:1) {
b_raw[i] ~ normal(p_coefs[i], sqrt(1 / p_taus[i]));
}

// prior for s(time)...
b_raw[2:9] ~ multi_normal_prec(zero[2:9],S1[1:8,1:8] * lambda[1] + S1[1:8,9:16] * lambda[2]);

// prior (non-centred) for s(series)...
b_raw[10:38] ~ std_normal();

// priors for smoothing parameters
lambda ~ normal(10, 25);

// priors for gp parameters
for (s in 1:n_lv){
b_gp[1:num_gp_basis, s] ~ std_normal();
}
rho_gp ~ inv_gamma(1.499007, 5.670433);

// priors for dynamic factor loading coefficients
L ~ student_t(5, 0, 1);

// priors for observation error parameters
sigma_obs ~ student_t(3, 0, 2);
{
// likelihood functions
vector[n_nonmissing] flat_trends;
vector[n_nonmissing] flat_sigma_obs;
flat_trends = (to_vector(trend))[obs_ind];
flat_sigma_obs = rep_each(sigma_obs, n)[obs_ind];
flat_ys ~ normal_id_glm(append_col(flat_xs, flat_trends),
0.0,append_row(b, 1.0),
flat_sigma_obs);
}
}


generated quantities {
vector[total_obs] eta;
matrix[n, n_series] sigma_obs_vec;
matrix[n, n_series] mus;
matrix[n, n_lv] LV;
matrix[n_series, n_lv] lv_coefs;
vector[n_sp] rho;
vector[n_lv] alpha_gp;
array[n, n_series] real ypred;
rho = log(lambda);
alpha_gp = rep_vector(0.25, n_lv);

// Sign correct factor loadings and factors
for(j in 1:n_lv){
if(lv_coefs_raw[j, j] < 0){
lv_coefs[,j] = -1 * lv_coefs_raw[,j];
LV[,j] = -1 * LV_raw[,j];
} else {
lv_coefs[,j] = lv_coefs_raw[,j];
LV[,j] = LV_raw[,j];
}
}

// posterior predictions
eta = X * b;
for (s in 1:n_series) {
sigma_obs_vec[1:n,s] = rep_vector(sigma_obs[s], n);
}
for(s in 1:n_series){ 
mus[1:n, s] = eta[ytimes[1:n, s]] + trend[1:n, s];
ypred[1:n, s] = normal_rng(mus[1:n, s], sigma_obs_vec[1:n, s]);
}
}

